//*** About the exceptional points of the 001 addition law for WC ***//
//** short form *//

BF := Rationals();
R1<a4,a6> := FunctionField(BF,2); // a1 = a2 = a3 = 0;
R2<X1,Y1,Z1, X2,Y2,Z2> := PolynomialRing(R1,6);
a1 := BF!0; a2 := BF!0; a3 := BF!0;


// Putting together the addition law for a=b=0, c=1  
mons := [ X1^2*X2^2,X1^2*X2*Y2,X1^2*X2*Z2, X1^2*Y2^2, X1^2*Y2*Z2,
          X1^2*Z2^2, X1*Y1*X2^2, X1*Y1*X2*Y2, X1*Y1*X2*Z2, X1*Y1*Y2^2,
          X1*Y1*Y2*Z2, X1*Y1*Z2^2, X1*Z1*X2^2, X1*Z1*X2*Y2, X1*Z1*X2*Z2,
          X1*Z1*Y2^2, X1*Z1*Y2*Z2, X1*Z1*Z2^2, Y1^2*X2^2, Y1^2*X2*Y2, 
          Y1^2*X2*Z2, Y1^2*Y2^2, Y1^2*Y2*Z2, Y1^2*Z2^2, Y1*Z1*X2^2, 
          Y1*Z1*X2*Y2, Y1*Z1*X2*Z2, Y1*Z1*Y2^2, Y1*Z1*Y2*Z2, Y1*Z1*Z2^2, 
          Z1^2*X2^2, Z1^2*X2*Y2, Z1^2*X2*Z2, Z1^2*Y2^2, Z1^2*Y2*Z2, Z1^2*Z2^2];
  
X3_001_ci := [ <-a2, 3>, <a1, 5>, <-a4, 6>, <2, 11>, <a3, 12>, <a2, 13>, 
               <1, 16>, <2*a3, 17>, <-3*a6, 18>, <-1, 21>, <-a1, 25>, 
               <-2, 26>, <-2*a3, 27>, <a4, 31>, <-a3, 32>, <3*a6, 33>];
Y3_001_ci := [ <-3, 2>, <a1*a2 - 3*a3, 3>, <-a1^2 - a2, 5>, 
               <a1*a4 - a2*a3, 6>, <3, 7>, <2*a2, 9>, <-2*a1, 11>, 
               <a4, 12>, <-a1*a2 + 3*a3, 13>, <-2*a2, 14>,
               <-2*a1*a3 - 2*a4, 17>, <3*a1*a6 - a3*a4, 18>, <-1, 23>, 
               <a1^2 + a2, 25>, <2*a1, 26>, <2*a1*a3 + 2*a4, 27>, <1, 28>, 
               <a3^2 + 3*a6, 30>, <-a1*a4 + a2*a3, 31>, <-a4, 32>, 
               <-3*a1*a6 + a3*a4, 33>, <-a3^2 - 3*a6, 35>];

Z3_001_ci := [ <3, 3>, <a2, 6>, <-a1, 12>, <-3, 13>, <a4, 18>, <-1, 24>, 
               <-a3, 30>, <-a2, 31>, <a1, 32>, <-a4, 33>, <1, 34>, <a3, 35>];
  
 X3_001 := R2!&+[R2!(X3_001_ci[i][1])*R2!(mons[Integers()!X3_001_ci[i][2]]): i in [1..#X3_001_ci]];
 Y3_001 := R2!&+[R2!(Y3_001_ci[i][1])*R2!(mons[Integers()!Y3_001_ci[i][2]]): i in [1..#Y3_001_ci]];
 Z3_001 := R2!&+[R2!(Z3_001_ci[i][1])*R2!(mons[Integers()!Z3_001_ci[i][2]]): i in [1..#Z3_001_ci]];

x3 := X3_001; y3 := Y3_001; z3 := Z3_001;

//--> set up to do checks <--//
WC1 := Y1^2*Z1+a1*X1*Y1*Z1+a3*Y1*Z1^2-X1^3-a2*X1^2*Z1-a4*X1*Z1^2-a6*Z1^3; 
WC2 := Y2^2*Z2+a1*X2*Y2*Z2+a3*Y2*Z2^2-X2^3-a2*X2^2*Z2-a4*X2*Z2^2-a6*Z2^3;
wc := { WC1, WC2 }; 

I0 := ideal< R2 | wc >;

I3 := ideal<  R2 | wc join {x3, y3, z3} >; 
printf "\n Computing the Groebner basis GB3 of the ideal I3 = <WC1,WC2,X3,Y3,Z3> takes this time: \n\t";
time GB3 := GroebnerBasis(I3);
printf "Said GB3 has %o elements.\n", #GB3;

// Monomials to describe the exceptional case P1=P2
xy := X1*Y2-X2*Y1;
xz := X1*Z2-X2*Z1;
yz := Y1*Z2-Y2*Z1;
xyz := { xy, xz, yz };

I10 := ideal< R2 | wc join xyz >;
printf "\n The ideal I10 = <WC1,WC2,X1*Y2-X2*Y1, X1*Z2-X2*Z1, Y1*Z2-Y2*Z1> is the one for the P1=P2 condition. Computing the Groebner basis GB10 of that ideal takes this time: \n\t";
time GB10 := GroebnerBasis(I10); 
printf "Said GB10 has %o elements.\n", #GB10;


//--> checks <--//
printf "\n We want to see that I3 = I10. We can try to do that by checking if they are subsets of each other:\n";
printf "\n\t Is I3 a subset of I10? \n\t";
I3 subset I10;

printf "\n\t Is I10 a subset of I3? \n\t";
I10 subset I3; 

printf "\n There can be a number of reasons why the second one is false so let's try a work around. For example, we can check if each of the elements of GB10 is in I3: \n\n"; 

for k := 1 to #GB10 do
    erin := GB10[k] in I3;
    k, erin;
end for;

printf "\n We can also check if other ideals generated by multiples of the elements of GB10 are subsets of I3, since that would imply I10 is a subset of I3. Like for example the ideal I10b:\n";

xyz2 := {a*b : a, b in xyz};
I10b := ideal< R2 | wc join xyz2 >;
printf "\n Computing the Groebner basis GB10b of the ideal I10b takes this time: \n\t";
time GB10b := GroebnerBasis(I10b);
printf "Said GB10b has %o elements.\n", #GB10b;

printf "\n\t Is I3 a subset of I10b? \n\t";
I3 subset I10b;
printf "\n\t Is I10b a subset of I3? \n\t";
I10b subset I3; 

printf "Is each of the elements of GB10b in I3? \n\n";

for k := 1 to #GB10b do
    erin := GB10b[k] in I3;
    k, erin;
end for;

printf"\n Ideal I10c";

xyz3 := {a*b : a in xyz, b in xyz2};
I10c := ideal< R2 | wc join xyz3 >;

printf "\n Computing the Groebner basis GB10c of the ideal I10c takes this time: \n\t";
time GB10c := GroebnerBasis(I10c); 
printf "Said GB10c has %o elements.\n", #GB10c;

printf "\n\t Is I3 a subset of I10c? \n\t";
I3 subset I10c;
printf "\n\t Is I10c a subset of I3? \n\t";
  I10c subset I3; 

printf "Is each of the elements of GB10c in I3? \n\n";
for k := 1 to #GB10c do
    erin := GB10c[k] in I3;
    k, erin;
end for;

printf"\n Ideal I10d";

xyz4 := {a*b : a, b in xyz2};
I10d := ideal< R2 | wc join xyz4 >;
printf "\n Computing the Groebner basis GB10d of the ideal I10d takes this time: \n\t";
time GB10d := GroebnerBasis(I10d);
printf "Said GB10d has %o elements.\n", #GB10d;

printf "\n\t Is I3 a subset of I10d? \n\t";
I3 subset I10d;
printf "\n\t Is I10d a subset of I3? \n\t";
I10d subset I3; 

printf "Is each of the elements of GB10d in I3? \n\n";
for k := 1 to #GB10d do
    erin := GB10d[k] in I3;
    k, erin;
end for;

printf "\n ALL TRUE!!";

quit;
